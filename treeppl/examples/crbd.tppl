/**  Constant-rate birth-death model */


// compiler hints, see Section 1.3
//~PARTICLES: 10000
//~METHOD: "SMC"

/**  Phylogenetic tree 
 * types, Section 0.4
 * Should go in library
 */
type Tree =
    | Leaf(age: Real, index: Int)
    | Node(age: Real, left: Tree, right: Tree)
// type DecoratedTree TODO
        
function flip(p: Real): Boolean {
    // assert(0 <= p <= 1)    later version
    e ~ Bernoulli(p)
    return e
}    

/**  Simulates side branches under the CRBD model
 * 

 * The following is a function that simulates the hidden
 * (extinct or undetected) evolutionary side-branches under
 * the CRBD model.
 * 
 * functions, see Section 0.2
 * 
 * In particular, it is clear that the return type of this
 * function is unit, as no explicit return specified and
 * it is a sequence of statements rather than a simple expression.
 */ 
function simulate_side_branch(start_time: Real, lambda: Real, mu: Real) {
    waiting_time ~ Exponential(lambda + mu)
    current_time = start_time - waiting_time // expressions, Section 0.1
    if current_time < 0 { // conditionals, Section 0.5
        weight(0) // <=> log_weight(-inf)
    } else {
        if flip(lambda/(lambda + mu)) {
            simulate_side_branch(current_time, lambda, mu) 
            simulate_side_branch(current_time, lambda, mu)
        }
    }   
}

/**
* Jan's walk over the tree
*/
function simulate_tree (child: Tree, parent: Tree, lambda: Real, mu: Real) {
    //~RESAMPLE // hint
    // k is the number of hidden speciation events
    k ~ Poisson(lambda*(parent.age - child.age)) // assume construct, .age without if is

    // loops, Section 0.6
    // 0 indexing of arrays
    // here, we don't have an index i
    // e.g.: for i in 1 to k
    // lst = 1 to 3
    // for x in lst
    // 1 to k == [1, 2, 3, ..., k]
    for 1 to k {
        t ~ Uniform(child.age, parent.age)        // positional arguments (now v1.0, names later)
        simulate_side_branch(t, lambda, mu)       // side effect on the weight
        weight(2) //  <=> log_weight(log(2)) 
    }

    // Observe Section 1.2
    // 0 extinctions events along the branch
    observe 0 ~ Poisson(mu*(parent.age - child.age))

    // pattern matching, Section 0.6 ("constructor matching")
    if child is Node {
        observe 0 ~ Exponential(lambda)
        simulate_tree(child.left, child, lambda, mu)
        simulate_tree(child.right, child, lambda, mu)
    }
    
    // Questions
    /********************************
    // child.age // defined 
    // child.left // undefined
    // if (child is Node) and (t < 0) // we think
    *********************************/
    // Boolean operators:
    // instead of
    //     &&, ||, !
    // we use 
    //   and, or, not
    // and we have
    //   xor
    // bitwise, vectorized TBD    
        
    // Explicit returns if we want the function to return a value.
    // 0.2 // error!
    // snake_case_function()
    // CamelCaseType
    // identifier_name
    // some_function() // returns a nuisance parameter, also error
    // If the end of the function has been reached without an explicit return,
    // the return type is unit, ()
}

/** 
 * Model 
 * 
 * Every program has a model function, see Section 1.4.
 *
 * - The function signature contains type annotations (postfix) for input (required) and return (not required unless recursive) 
 * - Default arguments (later, not in 1.0)
 * - Types are Capitalized
 * - Unicode is supported for identifiers within the model, but the interface to the world is ASCII
 *  
 * @param k_l shape of Gamma distribution for prior λ
 * @param t_l scale of Gamma distribution for prior λ
 * @param k_m shape of Gamma distribution for prior μ
 * @param t_m scale of Gamma distribution for prior μ
 *
 * @return {lambda: Real, mu: Real}
 *
 */ 
model function crbd(k_l: Int, t_l: Real, k_m: Int, t_m: Real, observation: Tree) {
    lambda ~ Gamma(k_l, t_l)
    mu ~ Gamma(k_m, t_m)
    if observation is Node {
        simulate_tree(observation.left, observation, lambda, mu)
        simulate_tree(observation.right, observation, lambda, mu)
    } 
    return {lambda, mu} 
    //return {lambda = lambda, mu = mu} // long-winded way 
    // return {mu, lambda} // still correct!
}
