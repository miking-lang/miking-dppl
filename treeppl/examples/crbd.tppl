/**  Constant-rate birth-death model */


// compiler hints, see Section 1.3
//~PARTICLES: 10000
//~METHOD: "SMC"

/**  Phylogenetic tree 
 * types, Section 0.4
 * Should go in library
 */
type Tree =
    | Leaf(age: Real, index: Int)
    | Node(age: Real, left: Tree, right: Tree)
// type DecoratedTree TODO
    

/**  Simulates side branches under the CRBD model
 * 

 * The following is a function that simulates the hidden
 * (extinct or undetected) evolutionary side-branches under
 * the CRBD model.
 * 
 * functions, see Section 0.2
 * 
 * In particular, it is clear that the return type of this
 * function is unit, as no explicit return specified and
 * it is a sequence of statements rather than a simple expression.
 */

simulate_side_branch = (start_time: float, λ: float, μ: float): () => {

    t ~ Exponential(rate=λ + μ) // sampling, section 1.2
    current_time = start_time - t // expressions, Section 0.1
    if (current_time < 0) { // conditionals, Section 0.5
        factor(-∞)
    } else {
        s ~ Bernoulli(λ/(λ + μ)) // positional invocation
        if (s) {
            simulate_side_branch(current_time, λ, μ) 
            simulate_side_branch(current_time, λ, μ)
        }
    }   
}



simulate_tree = (child: tree, parent: tree, λ: float, μ: float) => {

    //~RESAMPLE 

    // k is the number of hidden speciation events
    k ~ Poisson(λ*(parent.age - child.age))

    // loops, Section 0.6
    // here, we don't have an index i
    // <=> for (i in 1 to k)
    for (1 to k) {
        t ~ Uniform(l=child.age, u=parent.age)
        simulate_side_branch(t, λ, μ)
        factor(log(2))
    }

    // Observe Section 1.2
    // 0 extinctions events along the branch
    observe 0 ~ Poisson(μ*(parent.age - child.age))

    // pattern matching, Section 0.6
    switch (child) {
        | Node => {
            observe 0 ~ Exponential(λ)

            simulate_tree(child.left, child, λ, μ)
            simulate_tree(child.right, child, λ, μ)
        }
    }
    
    return ()
}

/** Model 
 * 
 * Every program has a model function, see Section 1.4.
 *
 * - The function signature contains type annotations for input and return
 * - Types are Capitalized
 * - Unicode is supported for identifiers within the model
 * - Interface is ascii
 * */ 
model function CRBD(k_l: Int = 1, t_l: Real = 0.2, k_m: Int = 1, t_m: Real = 0.1, observation: Tree): {lambda: Real, mu: Real} {
    λ ~ Gamma(k_l, t_l)
    μ ~ Gamma(k_m, t_m)
    // assert that observation is Node
    simulate_tree(observation.left, observation, λ, μ)
    simulate_tree(observation.right, observation, λ, μ)
    return {lambda = λ, mu = μ}   
}
