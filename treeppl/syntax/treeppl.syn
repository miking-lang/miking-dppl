token String
token LName -- lower case identifier, also LIdent
token UName -- upper case identifier, also UIdent
token Integer

/-
Try to give shorthand names to types, long names to production rules.
-/
type File
type TypeDecl
type FunDecl
type ModelFunDecl
type Cons
type Stmnt
type Expr

start File

/-
A file needs to have exactly one model function,
zero or more functions, and zero or more type declarations.
-/
prod File: File = model:ModelFunDecl
		  func:FunDecl*
		  type:TypeDecl*

/-
A regular (non-model) function is declared with the keyword function,
it has zero or more arguments, all of which are type-annotated, it has an
optional return type, and the body is given in { }. It consists of staments.
-/
prod Function: FunDecl =
  "function" name:LName
  "(" (args:LName ":" argsType:UName)? ("," args:LName ":" argsType:UName)*)? ")"
  (":" returnType:UName)?
  "{" body:Statement+ "}"

/-
A model function is a function preceeded by the keyword model
-/
prod ModelFunction: ModelFunDecl =
  "model" FunDecl

/-
A (type) constructor is similar to a function but needs to have at least one
argument, and does not have the optional postfix :SomeType
-/
prod Constructor: Cons =
  name:UName "(" args:LName ":" argsType ("," args:LName ":" argsType:UName)*)? ")"

/-
You can declare a type either via a simple constructor...
-/
prod SimpleTypeDeclaration: TypeDecl = "type" name:UName "=" Cons

/-
... or, via several alternative constructors preceeded by "|"
-/
prod TypeDeclaration: TypeDecl = "type" name:UName "=" ("|" Cons)+


/-
TO BE CONTINUED...
-/

prod Int: Expr = val:Integer
prod String: Expr = val:String
prod Variable: Expr = ident:LName
prod left Add: Expr = left:Expr "+" right:Expr
prod left Sub: Expr = left:Expr "-" right:Expr
prod left Mul: Expr = left:Expr "*" right:Expr
prod left Div: Expr = left:Expr "/" right:Expr
prod FunctionCall: Expr = f:Expr "(" (args:Expr ("," args:Expr)*)? ")"

precedence {
  FunctionCall;
  Mul Div;
  Add Sub;
}
