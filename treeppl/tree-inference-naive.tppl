/// Tree Builder Example in TreePPL ///

/** 
 * This file should be self-contained and can be used to check the TreePPL compiler.
 * 
 * The dependecies are the language features and several built-in distributions.
 *
 * Several things will go from here into a library for TreePPL.
 */

/// Distributions ///

/** We need the following distributions. 
 * Following syntax is to document this, not essential to the language */
use Permutation
use Categorical
use Exponentual
use Dirichlet

/// Types ///

/** A state can be one of 4 possible states **/
type State = 0 | 1 | 2 | 3

/** An array containing all four states **/
const States: State[4] = [0, 1, 2, 3]

/** Numbers */
type NonnegativeReal = x where x: Real, x >= 0
type PositiveReal = x where x: Real, x > 0

/** Tree */
type LeafType = "leaf"
type NodeType = "node"

const Leaf: LeafType = "leaf"
const Node: NodeType = "node"

type Leaf = {
    type: LeafType,
    index: BigInt,
    age: NonnegativeRea;l,
    states: State[]
}

type Tree = {
    type: NodeType,
    left: Tree | Leaf,
    right: Tree | Leaf,
    age: NonnegativeReal,
    states: State[]
}

/** Probabilities and rates */
type Probability = x  where x: Real, x <= 1, x >= 0

type Rate = x where x: Real, x <= 1, x >= -1

type Age = x where x: Real, x >= 0

type Time = Age

type InstantaneousRateMatrix = Rate[][]
// Potentially InstantaneousRateMatrix = A where A: Rate[][], checksum(A)
// checksum checks that the rows sum up to 1


/// Data ///

/** Just two states here but our model supports four states */
D: State[][] =  // alternative Matrix<State>
    [ [ 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
      [ 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
      [ 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ],
      [ 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] ]


/// Nucleotide Models ///

/** Generalized Time-Reversible
 *
 * @param p base frequency vectoir
 * @param r rates vector, see details
 * @return the transition matrix for GTR
 *
 *  The rates frequency vector encodes the transitions as follows
 *   r[0] : A -> C (alpha) 0 -> 1
 *   r[1] : A -> G (beta)  0 -> 2
 *   r[2] : A -> T (gamma) 0 -> 3
 *   r[3] : C -> G (delta) 1 -> 2
 *   r[4] : C -> T (eta)   1 -> 3
 *   r[5] : G -> T (nu)    2 -> 3
 */
gtr = function(p: Probability[4], r: Rate[5]) => InstantaneousRateMatrix
{
   Q = [ [ -(r[0]*p[1] + r[1]*p[2] + r[2]*p[3]), r[0]*p[1], r[1]*p[2], r[2]*p[3] ],
                 [ r[0]*p[0], -(r[0]*p[0] + r[3]*p[2] + r[4]*p[3]), r[3]*p[2], r[4]*p[3] ],
	         [ r[1]*p[0], r[3]*p[1], -(r[1]*p[0] + r[3]*p[1] + r[5]*p[3]), r[5]*p[3] ],
		 [ r[2]*p[0], r[4]*p[1], r[5]*p[2], -(r[2]*p[0] + r[4]*p[1] + r[5]*p[2]) ] ]

   f = -1/(
	    p[0]*Q[0][0] + p[1]*Q[1][1] * p[2]*Q[2][2] + p[3]*Q[3][3]
	)

   return [ [ f*Q[0][0], f*Q[0][1], f*Q[0][2], f*Q[0][3] ],
	      [ f*Q[1][0], f*Q[1][1], f*Q[1][2], f*Q[1][3] ],
	      [ f*Q[2][0], f*Q[2][1], f*Q[2][2], f*Q[2][3] ],
	      [ f*Q[3][0], f*Q[3][1], f*Q[3][2], f*Q[3][3] ] ] 
}


/** 
 * Calculate transition probabilities
 * 
 * @param Q rate matrix
 * 
 * @return a matrix encoding the transition probabilities
 *           from one state to another 
 *
 */
transition_probabilities = function(Q) => Probability [4, 3]
{
    P = [ [-Q[0][1]/Q[0][0], -Q[0][2]/Q[0][0], -Q[0][3]/Q[0][0] ],
	  [-Q[1][0]/Q[1][1], -Q[1][2]/Q[1][1], -Q[1][3]/Q[1][1] ],
	  [-Q[2][0]/Q[2][2], -Q[2][1]/Q[2][2], -Q[2][3]/Q[2][2] ],
	  [-Q[3][0]/Q[3][3], -Q[3][1]/Q[3][3], -Q[3][2]/Q[3][3] ] ]
    
    return P
}



/**
 * CTMC Process for a sequence of states
 *
 */
ctmc = function(
    parental_state: State,
    evolution_time: Time,
    Q: InstantaneousRateMaterix,
    P: Probability[4][3],
    mu: PositiiveReal = 1
) => State
{
   
    possible_next_states = States[-parental_state]
    
    // The waiting time until the transition is given by the negative
    // of the diagonal of the transition matrix
    lambda = -mu*Q[parental_state][parental_state]
    t ~ Exponential(rate = lambda)
    
    if (evolution_time - t < 0) {
	// no transition
	return parental_state
    }

    new_state ~ Categorical(probabilities =  P[starting_state], support = possible_next_states)
    
    return evolve(new_state, evolution_time - t, Q, P, mu)
}


/** 
 * Stationary distribution of the transition matrix Q
 *  Amounts to calculating the left eigenvector of the matrix
 *  Hint:  https://brilliant.org/wiki/stationary-distributions/
 */
stationary_distribution = function(Q: InstantaneousRateMatrix) => Probability[4]
{
    // TODO implement stationary distribution
}



/// Tree Stuff ///

/** Leaf 
 * @param index the leaf number
 * @param states the states of the leaf
 * @return leaf
 */
leaf = function(index: BigInt, states: State[]) => Leaf
{
    return {
	type: Leaf,
	index: index,
	age: 0.0,
	states: states
    }
}


/** Node */
node = function(left: Tree | Leaf, right: Tree | Leaf, age: NonnegativeReal, states: State[]) => Tree
{
    return {
	type: Node,
	left: left,
	right: right,
	age: age,
	states: states
    }
}

/** Convert tree to Newick */
top_to_newick = function(t: Tree)
{
    // TODO not implemented
}

/// Core model functions ///


/** Recursive function to randomly build a tree */
cluster = function(
    Q: InstantaneousRateMatrix,
    trees: Array<Tree>,
    max_age : Age
) => Array<Tree>
{
    // Check if we are done
    if trees.length == 1
        return trees

    // Pick two random trees in the trees vector
    v ~ Permutation(0:(trees.length - 1))
    i = v[0]
    j = v[1]

    // Propose s (new node states) from arbitrary proposal distribution (here stationary distribution)
    propose s ~ iid(
	dist = Categorical(probabilities = stationary_distribution(Q), support = States),
	n = trees[i].states.length
    )
    
    // Propose node_age (new node age) from prior 
    t ~ Exponential(rate = 20.0)
    parental_age = max_age + t 

    // Combine picked pair of trees into a new node
    parental_node = node(left = trees[i], right = trees[j], age = parental_age, states = s)

    // Observe states iid from continuous time Markov chain (CTMC)
    // Note that trees[i].states can be observed if trees[i] is a leaf, otherwise it
    // is a latent variable
    // trees[i].states ~ iid( CTMC( parental_node.states, Q, parental_node.age - trees[i].age ) )
    // trees[j].states ~ iid( CTMC( parental_node.states, Q, parental_node.age - trees[j].age ) )
    // (comprehension style)
    // These could probably be pre-computed
    somehow because it is only 4 characters,
    // and always the same time. So this is not the most efficient way to write it.
    trees[i].states ~ Infer(
	ctmc(
	    parental_state = parental_node.states[k],
	    evolution_time = parental_node.age - trees[i].age,
	    Q = Q,
	    P = transition_probabilities(Q)
	)
    ) where k in 0:(new_node.states.length - 1)
    
    // Compute new_trees vector
    // new_trees = trees.rm( trees[i], trees[j] ).add( new_node )
    // ...arr1 converts the array to arguments, think unlist in R
    // -[i,k] removes i-th and k-th position from the array
    new_trees = [...trees[-[i,k]], new_node]
    
    // cluster new_trees
    cluster(Q = Q, trees = new_trees, max_age = node_age)
}


// Define model
// this limitations that models are functions of 0 arguments should not be present
let model = function () => String
{
    pi ~ Dirichlet([1, 1, 1, 1]),
    //Q = scaled_rate_matrix( pi:pi, er: [1,1], state_labels: ["0","1"] )
    
    Q = gtr(p = pi, r = rep(1, 6))
	    
    // Define the initial trees vector (containing leaves)
    leaves = [leaf(states = D[0]), leaf(states = D[1]), leaf(states = D[2]), leaf(states = D[3])]
    
    // Build the tree by random clustering
    tree = cluster(Q = Q, trees = leaves, max_age = 0.0)[0]
    
    // Assumption about the draw of root states
    Dist = Categorical(probabilities = stationary_distribution(Q), support = [0, 1, 2, 3])
    observe tree.states ~ iid(Dist, tree.states.length)

    // Convert tree to readable format
    tree_string = top_to_newick(tree)

    // Return tree
    return tree_string
}

/// Inference ///
dist = Infer(model = model, method='SMC')
dist
