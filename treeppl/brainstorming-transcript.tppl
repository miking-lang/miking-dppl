
Math.log()


// Types are:
//   - optional
//   - inferred
function simple_evolution_model(  observed_nucleotide:   Phylo.Nucleotide,
                                  sequencing_accuracy_p: Real in [0, 1],
                                  sequencing_accuracy_p: Probability,
                                  sequencing_accuracy_p: Real passes positive_probability,
                                  Q : Phylo.InstantaneousRateMatrix,
                                  Q : Real[][] passes check_QTR,
                                  time : Real,
                                  Î¼ : Real in [0, Infinity)
                                ) : Nucleotide
{
  let a = 1;
}


/////////////////////////////////////////////////////////////////////////////////////////


///////// Help functions /////////////

// Tree leaf constructor
leaf = function( index, states )
{
    return { type: "leaf", index: index, age: 0.0, states: states };
}

// Tree node constructor
node = function( left, right, age, states )
{
    return { type: "node", left: left, right: right, age: age, states: states };
}


// Recursive function to convert a tree to a Newick string (with ages and not branch lengths)
var tree_to_Newick = function( tree )
{
    if ( tree.type == "leaf" )
        return tree.index + ":" + tree.age;
    else
        return "(" + tree_to_Newick( tree.left ) + "," + tree_to_Newick( tree.right ) + "):" + tree.age;
}

// Recursive function to convert a tree topology to a Newick string
var top_to_Newick = function( tree )
{
    if ( tree.type == "leaf" )
        return tree.index;
    else
        return "(" + top_to_Newick( tree.left ) + "," + top_to_Newick( tree.right ) + ")";
}


//////// Data //////////
// reference typescript syntax
// var arr_name:datatype[][]=[ [val1,val2,val3],[v1,v2,v3] ]
// Notes : semicolon (;) is optional
// Specify the data we have
D:Boolean[?, ?] passes some_function =
    [ [ 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
      [ 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
      [ 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ],
      [ 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] ]

//////// Core model functions //////////

// Recursive function to randomly build a tree
var cluster = function( Q, trees, max_age )
{
    // Check if we are done
    if ( trees.length <= 1 )
        return trees;

    // Pick two random trees in the trees vector
    (i, j) ~ RandomOrderedPair( 0:trees.length-1 );

    // Propose s (new node states) from arbitrary proposal distribution (here stationary distribution)
    // optional labelling of arguments R-style
    // default values, reordering the named values should be possible, mixing of keyword and positional should be possible
    propose s ~ iid( dist = Q.stationary(), n = trees[i].states.length )

    // Propose node_age (new node age) from prior 
    t ~ Exponential( rate = 20.0 ) guided by WhatEverDist( a = 11 )
    node_age = max_age + t;

    // Combine picked pair of trees into a new node
    new_node = node( trees[i], trees[j], node_age, s );

    // Observe states iid from continuous time Markov chain (CTMC)
    trees[i].states ~ iid( CTMC( new_node.states, Q, new_node.age - trees[i].age ) );
    trees[j].states ~ iid( CTMC( new_node.states, Q, new_node.age - trees[j].age ) );

    // Compute new_trees vector
    new_trees = trees.rm( trees[i], trees[j] ).add( new_node );

    // cluster new_trees
    cluster( Q, new_trees, node_age );
}

propose a ~ Exponential(rate = 1)
sample a ~ Exponential(rate = 2)


propose a ~ Exponential(rate = 1)
observe a ~ Exponential(rate = 2)

// Define model
var model = function ()
{
    // Construct rate matrix
    pi ~ Dirichlet( 1, 1 );
    Q = scaledRateMatrix( pi:pi, er: [1,1], states: ["0","1"] );

    // Define the initial trees vector (containing leaves)
    // We might want to introduce an observe distribution that goes from latent
    // states to actual observed conditions, that is, the observed states are
    // drawn iid from this distribution given the latent states
    leaves = [ leaf(0, D[0]), leaf(1, D[1]), leaf(2, D[2]), leaf(3, D[3]) ]

    // Build the tree by random clustering
    var tree = cluster( leaves, 0.0 )[ 0 ];

    // Assumption about the draw of root states
    var dist = Categorical( { ps: [0.8, 0.2], vs: [0, 1] } );
    observe tree.states ~iid( dist, tree.states.length );

    // Convert tree to readable format
    var tree_string = top_to_Newick( tree );

    // Return tree
    return tree_string;
}

///////// Inference ////////

// Do inference
Dist = Infer( model: model, method: 'SMC', particles: 10000 );
console.log( Dist );



